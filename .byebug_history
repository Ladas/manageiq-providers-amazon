quit
hash
x
 hash[x]
quit
inventory_collection.noop?
inventory_collection
c
inventory_collection
inventory_collection.noop?
quit
inventory_object
inventory_object.inventory_collection.parent_inventory_collections.blank?
targeted?
quit
inventory_collection.data.first.manager_uuid
inventory_collection.data.first.inventory_object.manager_uuid
inventory_collection.parent_inventory_collections
parent_inventory_collections
inventory_collection.skeletal_manager_uuids
inventory_collection.manager_uuids
inventory_collection.data
inventory_collection.noop?
quit
inventory_collection.noop?
nventory_collection.noop?
self
quit
Vm.first
persister.vms.saved?
persister.vms.data.saved?
persister.vms.data
persister.vms
persister
quit
Hardware.first
Vm.first
quit
inventory_collection.model_class.new(kva).attributes.symbolize_keys
kva["'\; SELECT * from users\; '"] = 'ss'
kva["\'; SELECT * from users; \'"] = 'ss'
kva["\'; SELECT * from users; \'"] = 'asd'
kva["'; SELECT * from users; '"] = 'asd'
kva
kva["'; SELECT * from users; '"] = 'asd'
kva = attributes_index.delete(index)
quit
 record.attributes.symbolize_keys
record.attributes
c
inventory_collection.saver_strategy == :concurrent_safe_batch
inventory_collection.data.first.data
inventory_collection.data
quit
quqit
inventory_collection
hashes
quit
inventory_collection
quit
inserted_record
inventory_object
quit
quoit
inventory_collection.model_class.where(select_query).explain
inventory_collection.model_class.where(select_query).to_sql
inventory_collection.model_class.where(select_query).count
inventory_collection.model_class.where(select_query)
quit
inventory_collection.model_class.where(select_query, cond).count
inventory_collection.model_class.where(select_query, cond)
c
inventory_collection.unique_index_columns.map { |x| ActiveRecord::Base.connection.quote(hash[x]) }.join(", ")
inventory_collection.unique_index_columns.map { |x| ActiveRecord::Base.connection.quote(hash[x]) }
n
indexed_inventory_objects
quit
indexed_inventory_objects
hash
inventory_collection.unique_index_columns.map { |x| ActiveRecord::Base.connection.quote(hash[x.to_s]) }
quit
c
hashes
c
inventory_collection
hashes
quit
c
insert_query
n
insert_query
n
hashes
quit
inventory_collection.db_collection_for_comparison_for_complement_of(inventory_collection.all_manager_uuids)
inventory_collection.all_manager_uuids
all_manager_uuids_size
quit
@ems.orchestration_stacks.count
n
@ems.orchestration_stacks.count
quit
total_elements - total_not_deleted_elements
@ems.vms.count
quit
pp Flavor.pluck(:ems_ref)
quit
pp Flavor.pluck(:ems_ref)
Flavor.pluck(:ems_ref)
quit
c
inventory_object.inventory_collection.foreign_keys
inventory_object.inventory_collection.fixed_foreign_keys
assert_referential_integrity(hash, inventory_object)
quit
inventory_object.inventory_collection.fixed_foreign_keys
x
quit
 inventory_object.manager_ref.select { |x| inventory_object.inventory_collection.association_to_foreign_key_mapping[x] }
 inventory_object.manager_ref.select { |x| inventory_object.inventory_collection.foreign_key_to_association_mapping[x] }
 inventory_object.manager_ref.select { |x| inventory_object.foreign_key_to_association_mapping[x] }
inventory_object.manager_ref
inventory_object.inventory_collection.dependencies
inventory_object
inventory_object.inventory_collection.fixed_dependencies
inventory_object.inventory.collection.fixed_dependencies
inventory_object.fixed_dependencies
hash
quit
hash
quit
hash
quit
inventory_collection.manager_uuids
association.to_sql
inventory_collection.parent.send(inventory_collection.association).to_sql
association.to_a
inventory_collection.parent.send(inventory_collection.association).to_a
c
inventory_collection.parent.send(inventory_collection.association).to_a
inventory_collection.parent.send(inventory_collection.association)
association.to_a
association.to_sql
quit
parent
manager
full_collection_for_comparison.where(manager_ref.first => (manager_uuids + skeletal_manager_uuids).to_a.flatten.compact).to_sql
full_collection_for_comparison.where(manager_ref.first => (manager_uuids + skeletal_manager_uuids).to_a.flatten.compact)
quit
inventory_collection.parent_inventory_collections.collect(&:manager_uuids).map(&:to_a).flatten
inventory_collection.parent_inventory_collections.collect(&:manager_uuids).map(&:to_a)
inventory_collection.parent_inventory_collections.collect(&:manager_uuids).flatten.to_a
inventory_collection.parent_inventory_collections.collect(&:manager_uuids)
inventory_collection.parent_inventory_collections.collect(&:manager_uuids).to_a.flatten
quit
association.to_sql
association
quit
pp caller
caller
stacktrace
@target
c
@target
target
quit
c
target
c
target
quit
c
quit
target
n
target
n
targets_with_inventory
n
target
n
target
n
self
references(:vms)
self
s
self.target
self
s
self.target
self
n
self
n
s
quit
c
manager
self
target
c
@target
n
target
s
raw_target
quit
self
target
quit
y
quit]
miq_templates = inve.detect {|x| x.name == :miq_templates}
inve.detect {|x| x.name == :miq_templates}
inve = ManagerRefresh::Inventory::Persister.from_yaml(persister.to_yaml).inventory_collections
c
pp hashes
hashes
quit
persister.to_yaml
quit
pp @orch_stack.orchestration_template
pp @orch_stack
@orch_stack.count
quit
pp OrchestrationTemplateCfn.all
pp OrchestrationTemplateCfn
OrchestrationTemplateCfn.first
OrchestrationTemplateCfn.count
quit
@orch_stack.orchestration_template.md5
@orch_stack.orchestration_template
quit
pp resources
pp collector.load_balancers
pp collector.network_ports.all.select{|x| x['description'] ==("ELB EmSRefreshSpecVPCELB")}
pp collector.network_ports.all.select{|x| x['description'].include?("EmSRefreshSpecVPCELB")}
pp collector.network_ports.all.select{|x| x['description']}
pp collector.load_balancers
pp collector.floating_ips
pp collector.load_balancers
pp collector.floating_ips
quit
@elb
@els
n
quit
persister.floating_ips.data_index['54.221.202.53']
quit
ip['domain']['standard']
ip['domain']['vpc']
ip
ip[:instance_id]
cloud_network_only
quit
